== Fonts ==

Fonts form the heart of the build system, given that they are the most complex component type to create and work with.

The minimum attributes a font object needs are: `target` and `source`. For example, the following `wscript` file is about as simple as one can get:

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.ttf')
----

This short file does more than might be expected. First of all it copies the input file `myfont.ttf` to an output file `build/results/myfont.ttf`footnote:[We will use unix style `/` for path separators]. This copy may seem redundant, but it is necessary for the rest of the system to work, and not all source fonts are unmodified `.ttf` files. It will also add this font to the default package, allowing a windows installer to be created. If there are tests `.txt` files in a directory called `tests` then these can be run against this font.

Notice that an input and an output file may not have the same name. Even if the output file ends up in `build/` it still corresponds to a real input file that may or may not be in `build/`. So file paths must be unique if the files are unique.

What if the source isn't a `.ttf` file. We can simply change the above example to:

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.sfd')
----

and the system will automatically convert the FontForge source font to TrueType as it is copied into the `build` results directory tree. Here we wouldn't actually need the `results/` prefix to the target because the filename isn't the same as the `source` attribute.

The complete list of core attributes to a font are:

target::
	Output file for the generated font within `build`.

source::
	Basic design file used to generate the initial form of the output font.

version::
	This takes a version number in the form 'x'.'y' (a floating point number) and sets the output font to have that version. It may also be a tuple of the form (x.y, "text") where the text will be appended to the version string inside the font.

sfd_master::
	This attribute specifies a FontForge file that should be merged with the source FontForge file when creating the target. If the sfd_master file is the same as the source, then sfdmeld is not run.

ap::
	Attachment point database associated with the source font.

classes::
	Classes .xml file that adds class information to the attachment point database before conversion into smart font source code.

copyright::
	Copyright string to insert into the font.

tests::
	Test object to use for test generation. If not specified, the global font test object is used.

package::
	Package object to insert this font into. If not specified the global package is used.


=== OpenType ===

There are two ways of adding OpenType information to a font. One is to already have it in the source font. This is the most common approach. We need to indicate to the font builder that we are working with an OpenType font, even if everything is internal to the font. The font builder needs to know for font testing purposes or if the font is generated from a legacy font.

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.sfd',
	 opentype = internal())
----

This will generate tests pertinent to OpenType testing. See the section on font tests.

One approach sometimes used for FontForge based projects is to keep all the lookups in one font and then to share these lookups across all the fonts in a project. For this we simply specify a `sfd_master` attribute and the font builder will use `sfdmeld` to integrate the lookups in the master into each font as it is built. There is no need to specify that the font is OpenType in this case, because that is obvious from the context:

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.sfd',
	 sfd_master = 'mymaster.sfd')
----

Obviously, if the `sfd_master` attribute is the same as the `source` file then no merge occurs. This is an alternative way of specifying that the font is OpenType.

Another approach to adding OpenType tables to a font is to use an external tool to create the lookups in and then to have that compile them into the font. Currently, the only external tool supported by the system is Microsoft's VOLT(Visual OpenType Layout Tool). This uses a command line volt compiler to integrate the `.vtp` source into the font. In addition, the `.vtp` source is autogenerated from a source and any other elements that go to make the final integrated source. For example we show a maximal `volt()` integration to show all the components and then discuss them.

Notice that while the initial parameter to such objects as `volt` is required, all named parameters are optional.

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.ttf',
	 opentype = volt('myfont.vtp',
					 master = 'mymaster.vtp'),
	 ap = 'myfont.xml',
	 classes = 'project_classes.xml')
----

We define the `.vtp` file to create for this font which will then be compiled into the font using `volt2ttf` as `myfont.vtp`. We also declare a shared master volt project that is shared between all the fonts (well at least this one!). In building a largely automated volt project, a program `make_volt` is used that can take attachment point information from an xml database `myfont.xml`. This may be augmented with class information using `project_classes.xml`. These two file references are within the font rather than the volt details because they are shared with other smart font technologies particularly graphite.

The complete list of attributes to Volt() are:

master::
	The volt source that is processed against the font to generate the font specific volt to be compiled into the font.

make_params::
	These parameters are passed to the make_volt process. The value is a string of parameters.

params::
	These parameters are passed to volt2ttf to modify the compiling of the volt source into OpenType tables.

no_make::
	If this attribute is present, make_volt isn't run and the first parameter is assumed to be the specific .vtp for this font.

=== Graphite ===

Adding Graphite tables to a font is much like adding VOLT information. The relevant files are declared either to the font or a `gdl()` object. For example:

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.ttf',
	 graphite = gdl('myfont.gdl',
					 master = 'mymaster.gdl'),
	 ap = 'myfont.xml',
	 classes = 'project_classes.xml')
----

Notice that the `ap` and `classes` attributes have the same values and meaning as for OpenType tables. This is because the information is used in the creation of both sets of tables. The `myfont.gdl` is created by the `make_gdl` process and it pulls in `mymaster.gdl` during compilation.

The complete list of attributes to a gdl() object are:

master::
	Non-font specific GDL that is #included into the font specific GDL.

make_params::
	Parameters passed to `make_gdl`.

params::
	Parameters to pass to `grcompiler` to control the compilation of Graphite source to Graphite tables in the font.

no_make::
	If this attribute is present, make_gdl is not run and the first parameter is assumed to be the gdl for the specific font.

=== Legacy Fonts ===

Many fonts are actually built from another font, either legacy encoded or generated from a source font or fonts. This can be achieved by giving a `legacy()` object as the `source` attribute for the font. For example, for a font generated from a legacy font using `ttfbuilder` we might do:

----
font(target = 'results/myfont.ttf',
	 source = legacy('myfont_src.ttf',
					 source = 'my_legacyfont.ttf',
					 xml = 'legacy_encoding.xml',
					 params = '-f ../roman_font.ttf',
					 ap = 'my_legacyfont.xml'))
----

The legacy object creates the source font that is then copied to the output and perhaps smarts are added too.

The complete set of attributes to a `legacy()` object is:

source::
	The legacy source font (`.ttf`) to use to convert to the Unicode source font.

xml::
	ttfbuilder configuration xml file to use for the conversion

params::
	Command line arguments to ttfbuilder. Note that files specified here need `../` prepended to them.

ap::
	Attachment point database of the legacy font that will be converted to the font.ap attribute file.

noap::
	Instructs the legacy converter not to create the ap database specified in the font. This would
	get used when another process, after legacy conversion, modifies the font and then you want the
	build system to autogenerate the ap database from that modified font rather than from the
	legacy font conversion process.

=== Licensing and Copyright ===

Fonts contain both copyright and license information. The `copyright` attribute is the copyright string for the font and if present that string will be inserted into the font as the copyright statement.

The license object is an object that describes how to generate the specific license for this font. It also allows the collecting of license information for all the fonts in a package. Currently, the only license type supported is the OFL. For example:

----
font(target = 'results/myfont.ttf',
	 source = 'myfont.ttf',
	 copyright = 'Copyright 2012, Acme <email|URL>',
	 license = ofl('myfont', 'Acme',
					version = 1.1,
					copyright = 'Copyright 2012, Acme Labs <email|URL>',
					file = "OFL.txt'))
----

The first parameter for the `ofl()` object is the list of Reserved Font Names (RFN). There may be more than one RFN. (For more details about the RFN mechanism please refer to the OFL FAQ: http://scripts.sil.org/OFL). These all appear in the license statement as the reserved font names for that particular version of the font project. In this example the name of the font and the name of the company of the author are reserved so that any derivative must be distinct from these two names. This is designed to allow all changes to the font but to prevent collision of fonts with different features but the same names. The goal is to reduce confusion for both font authors and font users. All the reserved font names in all the fonts in a package - various other authors can indicate their own reserved font names - are collected into one list that is then put into the license for the package. The OFL version may be given and defaults to 1.1. The copyright message is put at the start of the license statement. If not specified the global variable COPYRIGHT is used for this. The file where the license ends up may be given but defaults to `OFL.txt`.


=== Tests ===

smith includes a powerful system for testing with the potential to add different types of font tests. Currently there is only one font test type and also by default a single font test object is created that is used by all fonts for which no tests attribute is given.

The `fonttest` object takes these attributes:

testdir::
	This gives the directory relative to which all test files are to be found in the source tree. If unspecified, the global variable TESTDIR is used to give a default value. If this isn't set then the `tests` dir is used. So if one had tests in a different directory the following would work:

----
TESTDIR = 'test-suite'
font(target = 'results/myfont.ttf',
	 source = 'myfont.ttf')
----

texts::
	This is a glob string or list of glob strings that describe the text files to use for testing. The default is `*.txt`. For each text file and each font a `.tex` file is created that references the text file, the font, the script and language. In addition tests are run for each smart font technology (`gr` and or `ot`). These files are then generated to pdf.

htexts::
	Creating text files for complex scripts when there is no keyboard and at the start of a development project, can be problematic. One approach is to simplify the entry of unicode codepoints through the use of a string in the text file of the form `\u`'xxxx' which is a unicode scalar identifier (including support for supplementary plane data). Such files (defaulting to `*.htxt` are preprocessed into the corresponding `*.txt` and added to the list of `texts` test files.

texs::
	The difference with these `.tex` files (defaulting to `*.tex`) is that they are treated as simply TeX files to be run through XeTeX for test purposes. This gives the user greater control over complex text runs than a simple text file can give.

test_suffix::
	The way a font is identified as part of a test result filename is based on the target file for that font. If a font has a `test_suffix` attribute then this is used instead for the font identifying name.
